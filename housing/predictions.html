<!DOCTYPE html>
<html>
<head>
  <title>TensorFlow.js linear regression</title>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-vis"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<body>

  <script type="text/javascript">

    // let model;
    // let points;
    // let normalisedFeature, normalisedLabel;
    // let trainingFeatureTensor, testingFeatureTensor, trainingLabelTensor, testingLabelTensor;
    const storageID = "kc-house-price-regression";

    // side effect: uses tf-vis library to show scatter plot
    const plot = (pointsArray, featureName) => {
      tfvis.render.scatterplot(
        { name: `${featureName} vs House Price`},
        { values: [pointsArray], series: ['original'] },
        { xLabel: featureName, yLabel: "Price" }
      );
    };

    const plotPredictionLine = async () => {
      alert("Not yet implemented")
    }

    // normalizes data
    const normalize = (tensor) => {
      const min = tensor.min()
      const max = tensor.max()
      const normalizedTensor = tensor
        .sub(min)
        .div(max
          .sub(min)
        )
      return {
        tensor: normalizedTensor,
        min,
        max,
      }
    };

    // denormalizes data
    const denormalize = (tensor, min, max) => {
      const denormalisedTensor = tensor
        .mul(max
          .sub(min)
        ).add(min);
      return denormalisedTensor;
    };

    // creates a linear regression model
    const createModel = () => {
      // creates sequential model
      const model = tf.sequential();

      // adds first layer to model
      model.add(tf.layers.dense({
        units: 1,
        useBias: true,
        activation: 'linear',
        inputDim: 1,
      }));

      // determines the loss, more useful for normalized data
      const lossFunction = 'meanSquaredError'

      // minimizes the loss function with stochastic gradient descent and a 0.1 learning rate
      const optFunction = tf.train.sgd(0.1);
      // adam works really well here too
      // const optFunction = tf.train.adam();

      // prepares model for training and evaluation
      model.compile({
        loss: lossFunction,
        optimizer: optFunction,
      })

      return model;
    };

    // trains the model
    const trainModel = async (model, trainingFeatureTensor, trainingLabelTensor) => {
      // using tfvis to monitor training
      const { onEpochEnd, onBatchEnd } = tfvis.show.fitCallbacks(
        { name: "Training Performance" },
        ['loss']
      )

      return model.fit(trainingFeatureTensor, trainingLabelTensor, {
        batchSize: 32,
        epochs: 20,
        validationSplit: 0.2,
        callbacks: {
          // onEpochEnd: (epoch, log) => console.log(`Epoch ${epoch}: loss = ${log.loss}`),
          onEpochEnd,
          onBatchEnd,
        }
      });
    };


    const predict = async () => {
      alert("Not yet implemented")
    };
    const save = async () => {
      alert("Not yet implemented")
    };
    const load = async () => {
      alert("Not yet implemented")
    };
    const test = async () => {
      alert("Not yet implemented")
    };
    const train = async () => {
      alert("Not yet implemented")
    };
    const toggleVisor = async () => {
      alert("Not yet implemented")
    };



    const run = async () => {
      // import from csv (source: https://www.kaggle.com/harlfoxem/housesalesprediction)
      const salesData = tf.data.csv("http://127.0.0.1:8080/housing/kc_house_data.csv");

      // extract points (x and y values) to plot
      const pointsData = salesData.map(record => ({
        x: record.sqft_living,
        y: record.price
      }))
      const points = await pointsData.toArray();

      // ensuring there are an even number of points, for the sake of splitting
      if (points.length % 2 !== 0) {
        points.pop();
      }

      // shuffling the points
      tf.util.shuffle(points);

      // graphing the points
      plot(points, "Square Feet")

      // extract inputs (features)
      // const featureValues = await pointsData.map(p => p.x).toArray()
      const featureValues = points.map(p => p.x)
      const featureTensor = tf.tensor2d(featureValues, [featureValues.length, 1])

      // extract outputs (labels)
      // const labelValues = await pointsData.map(p => p.y).toArray()
      const labelValues = points.map(p => p.y)
      const labelTensor = tf.tensor2d(labelValues, [labelValues.length, 1])

      // normalize features and labels
      const normalizedFeature = normalize(featureTensor)
      const normalizedLabel = normalize(labelTensor)

      // test denormalization
      denormalize(
        normalizedFeature.tensor,
        normalizedFeature.min,
        normalizedFeature.max,
      ).print();

      // splitting data into training and testing data
      const [trainingFeatureTensor, testingFeatureTensor] = tf.split(normalizedFeature.tensor, 2);
      const [trainingLabelTensor, testingLabelTensor] = tf.split(normalizedLabel.tensor, 2);

      // creating model
      const model = createModel();
      const layer = model.getLayer(undefined, 0);
      model.summary();
      tfvis.show.modelSummary({ name: 'Test model' }, model)
      tfvis.show.layer({ name: 'Test layer 1' }, layer)

      // training model
      const result = await trainModel(model, trainingFeatureTensor, trainingLabelTensor);
      const trainingLoss = result.history.loss.pop();
      const validationLoss = result.history.val_loss.pop();
      console.log(result)
      console.log(`Training set loss: ${trainingLoss}`);
      console.log(`Validation set loss: ${validationLoss}`);

      // evaluating the model
      const lossTensor = model.evaluate(testingFeatureTensor, testingLabelTensor);
      const loss = await lossTensor.dataSync();
      console.log(`Testing set loss: ${loss}`);
    }

    // run();

  </script>

  <!--   Header   -->
  <div class="section no-pad-bot" id="index-banner">
    <div class="container">
      <h5 class="header center blue-text small">
        Linear regression with TensorFlow.js
      </h5>
      <div class="row center">
        <h6 class="header col s12 light">
          Train a model to predict house price from living space.
        </h6>
      </div>
    </div>
  </div>

  <!--   Misc buttons   -->
  <div class="section no-pad-bot light-blue lighten-4">
    <div class="container">
      <div class="row center">
        <button
          id="toggle-button"
          class="waves-effect waves-light light-blue btn-small"
          onclick="toggleVisor()"
        >
          Toggle Visor
        </button>
        <br/><br/>
      </div>
    </div>
  </div>

  <!--   Main functionality   -->
  <div class="container">
    <div class="section">

      <div class="row">
        <!--   Training   -->
        <div class="col s12 m6">
          <div class="icon-block">
            <h3 class="center light-blue-text">
              <i class="material-icons" style="font-size: 2em">build</i>
            </h3>
            <h5 class="center">Train & Test</h5>

            <p class="light"></p>

            <div>
              <p>
                <label>Training status:</label>
              </p>
              <pre
                class="grey lighten-4"
                style="overflow-x: auto"
              >
                <em id="model-status">Loading data...</em>
              </pre>

              <p>
                <label>Testing status:</label>
              </p>
              <pre
                class="grey lighten-4"
                style="overflow-x: auto"
              >
                <em id="testing-status">Not yet tested</em>
              </pre>

              <button
                autocomplete="off"
                id="train-button"
                class="waves-effect light-blue waves-light btn"
                disabled
                onclick="train()"
              >
                Train New Model
              </button>
              <button
                autocomplete="off"
                id="test-button"
                class="waves-effect light-blue waves-light btn"
                disabled
                onclick="test()"
              >
                Test Model
              </button>
            </div>
            <br/>

            <div>
              <button
                autocomplete="off"
                id="load-button"
                class="waves-effect light-blue waves-light btn-small"
                disabled
                onclick="load()"
              >
                Load Model
              </button>
              <button
                autocomplete="off"
                id="save-button"
                class="waves-effect light-blue waves-light btn-small"
                disabled
                onclick="save()"
              >
                Save Model
              </button>
            </div>

          </div>
        </div>

        <!--   Prediction   -->
        <div class="col s12 m6">
          <div class="icon-block">
            <h3 class="center light-blue-text">
              <i class="material-icons" style="font-size: 2em">timeline</i>
            </h3>
            <h5 class="center">Predict</h5>

            <label>
              Square feet of living space:
              <input
                type="number"
                id="prediction-input"
                placeholder="2000"
              />
            </label>
            <button
              autocomplete="off"
              id="predict-button"
              class="waves-effect light-blue waves-light btn"
              disabled onclick="predict()"
            >
              Predict house price
            </button>
            <p>
              <strong id="prediction-output"></strong>
            </p>
          </div>
        </div>
      </div>

    </div>
  </div>



</body>
</html>
